<?php

namespace App\Http\Controllers;

use App\Models\Post;
use Illuminate\Support\Facades\DB; // Автоматически прописываем пространство имен для использования класса Facades\DB

class HomeController extends Controller { // Контроллер (класс) для работы с главной страницей
// -->> LARAVEL по умолчанию, возвращает данные в формате JSON!

//    public function index () { // Метод для вывода на главную страницу


/* ---------- Running SQL Queries (Выполнение raw SQL запросов -----------*/


        // Метод INSERT (добавляет записи в соответствующие таблицы существующей БД). Возвращает true|false
        /*$query = DB::insert ("INSERT INTO posts (title, content, created_at, updated_at) VALUES (?, ?, ?, ?)", ['Статья 3', 'Контент статьи 3', NOW(), NOW()]);*/
//        $query = DB::insert ("INSERT INTO posts (title, content) VALUES (?,?)", ['Статья 5', 'Контент статьи 5']); // Вставляем в таблицу posts в БД в поля title, content данные 'Статья 3', 'Контент статьи 3'
//        var_dump ($query);
        /*DB::insert ("INSERT INTO posts (title, content) VALUES (:title,:content)", ['content' => 'Контент статьи 5', 'title' => 'Статья 5']); */// Вариант написания запроса с использованием именованных параметров :title,:content. При указании их значений, мы можем их перечислить в произвольной последовательности ['content' => 'Контент статьи 5', 'title' => 'Статья 5']

        // Метод UPDATE (обновляет записи в соответствующих таблицах существующей БД). Возвращает количество измененных записей
        /*DB::update ("UPDATE posts SET created_at = ?, updated_at = ? WHERE created_at IS NULL OR updated_at IS NULL", [NOW(), NOW()]);*/ // Обновим данные для таблицы posts и установим новые значения для полей created_at = ?, updated_at = ? значения которых пустые - IS NULL


        // Метод DELETE (удаляет записи в соответствующих таблицах существующей БД). Возвращает количество удаленных записей
        /*DB::delete ("DELETE FROM posts WHERE id = ?", [5]);*/ // Удалим данные (запись) из таблицы posts, id которой равен [5]



        // Метод SELECT (выбирает записи из соответствующих таблиц существующей БД). Возвращает массив записей
        /*$posts = DB::select ("SELECT * FROM posts WHERE id > :id", ['id' => 2]);*/ // Создадим переменную и присвоим ей значение выборки из БД laravel таблица posts используя класс Facades\DB и метод select. В результате получим массив с данными в формате json. При выполнении условия, мы используем именованный параметр ":id" и задаем ему значение ['id' => 2]
//        return $posts;


        /*dump (config ('app.timezone')); // config - это функция хелпер, она так же может вернуть значение или она может его установить function config($key = null, $default = null)
        dump (config ('database.connections.mysql.database')); // Если нам нужно вывести значение переменной, которая находится в файле в многомерном массиве, тогда мы указываем полный путь к переменной, начиная с названия файла, перечислением ключей массива до нужного ключа, отделяя каждый новый ключ точкой. 'database' => env('DB_DATABASE', 'forge') - означает, что если в настройках окружения переменной не указана настройка 'DB_DATABASE' (нет такой записи), тогда ключу 'database' будет присвоено значение 'forge'

        dump ($_ENV); // Распечатка настроек глобальной переменной $_ENV
        dump ($_ENV['DB_CONNECTION']); // Распечатка значения конкретной переменной 'DB_CONNECTION' из глобального массива $_ENV*/

//        return view ('home', ['res' => 5, 'name' => 'John']); // Подключаем шаблон для вывода вида

//    }

    public function test () { //

       return __METHOD__;

    }

    // -->> Listening For Query Events - Мы можем отслеживать SQL запросы и те "привязки" (['id' => 2]) которые выполняет Laravel. Если мы хотим получить каждый выполненный запрос, мы можем использовать специальный метод "listen". Данный метод мы можем использовать для логирования запросов, для отладки и при прочей необходимости. Сделать это можно в AppServiceProvider.php

    // -->> Database Transactions - В Laravel есть удобный метод для механизма транзакций (транзакции обеспечивают целостность данных в БД). Например, мы работаем одновременно с несколькими таблицами (таблицы category | posts), если мы удаляем категорию, нам нужно удалить и посты, которые к ней привязаны. Если мы вдруг, удалим категорию и что-то пойдет не так с удалением постов - у нас получится в БД удаленной категории уже нет, а сами привязанные посты остались. Нам нужно сделать так, чтобы: ИЛИ удалялись и категория и связанные посты, ИЛИ не удалялось нечего (обеспечение целостности БД). Для этого:
/*    public function index () {

        DB::beginTransaction (); // Запускаем транзакцию
        try {

            // Выполняем запросы
            DB::update ("UPDATE posts SET created_at = ? WHERE created_at IS NULL ", [NOW()]);
            DB::update ("UPDATE posts SET updated_at = ? WHERE updated_at IS NULL ", [NOW()]);

            DB::commit (); // Если оба запроса выполнятся без ошибок, тогда мы их commit
        } catch (\Exception $e) {

            DB::rollBack (); // Откатим изменения
            echo $e->getMessage (); // Выводим информацию об ошибке в браузер
        }


        $posts = DB::select ("SELECT * FROM posts WHERE id > :id", ['id' => 2]);
        return $posts;
    }*/

// -->> Выполнение запроса общего типа

//Некоторые операторы базы данных не возвращают никакого значения. Для этих типов операций вы можете использовать метод statement фасада DB:
//DB::statement('drop table users');



/* ---------- Database: Query Builder (Выполнение SQL запросов с помощью конструктора запросов -----------*/


//    public function index () {

        /*$data = DB::table ('country')->get ();*/ // Объявляем переменную $data и будем работать с конструктором запросов. Для этого, нам нужно обратиться к классу DB и использовать метод table, который укажет на нужную нам таблицу. Метод table возвращает экземпляр конструктора запросов и позволяет добавлять к данному запросу дополнительные условия. Для получения данных используем метод get

        /*$data = DB::table ('country')->limit (5)->get ();*/ // Чтобы ограничить выборку данных, используем метод limit с указанием числа отображаемых записей limit (5) (первые 5 стран). По умолчанию, при выборке 5 стран не всегда может быть гарантирована выдача в алфавитном порядке (обычно по первому полю). Чтобы гарантированно получить ожидаемый результат, нужно использовать по конкретному полю ORDER BY имя_поля ASC|DESC

        /*$data = DB::table ('country')->select ('Code', 'Name')->limit (5)->get ();*/ // Чтобы выбрать из данной выборке по каждой записи только часть полей используем метод select - select ('Code', 'Name')

        /*$data = DB::table ('country')->select ('Code', 'Name')->first ();*/ // Метод first - он позволяет вернуть первую запись из таблицы

        /*$data = DB::table ('country')->select ('Code', 'Name')->orderBy ('Code', 'desc')->first ();*/ // Устанавливаем порядок сортировки используя метод orderBy - передаем колонку для сортировки и вид сортировки ASC | DESC (по умолчанию ASC)

        /*$data = DB::table ('city')->select ('ID', 'Name')->find (2);*/ // Мы можем выбрать единственную запись по ID из таблицы city используя метод find и указываем ID записи (2) - "select `ID`, `Name` from `city` where `id` = ? limit 1"

// -->> В Laravel нет необходимости подготавливать (безопасно) SQL запрос ("DELETE FROM posts WHERE id = ?", [5]). Программа делает это за нас по умолчанию: (предыдущий запрос преобразован) "select `ID`, `Name` from `city` where `id` = ? limit 1"

        /*$data = DB::table ('city')->select ('ID', 'Name')->where ('id', '=',2)->get ();*/ // Мы можем более гибко управлять условиями для выборки данных используя метод where. Здесь мы можем передать три аргумента: первый - колонка, которая участвует в условии, второй - оператор (=,>,< итд) (указывать не всегда обязательно), третий - значение, которое участвует в условии. Для получения данных используем метод get - получаем многомерный массив

        /*$data = DB::table ('city')->select ('ID', 'Name')->where ([
            ['id', '>',  1],
            ['id', '<',  5],
        ])->get ();*/ // Если мы хотим использовать одновременно несколько условий, тогда в методе where мы указываем массив с перечисленными в нем условиями в виде отдельных массивов для каждого условия (многомерный массив)

        /*$data = DB::table ('city')->where ('id', '<',  5)->value ('Name'); */// Если нам нужно получить значение только одного столбца, но без использования метода select - для этого мы используем метод value: аргументом мы указываем название колонки, значение которой мы хотим получить (это не массив, это будет строка)

        /*$data = DB::table ('country')->limit (10)->pluck ('Name', 'Code');*/ // Чтобы нам получить все значения конкретного столба, мы используем метод pluck. Для того, чтобы ключами были идентификаторы, мы указываем в методе pluck второй аргумент с указанием колонки идентификаторов 'Code'

        // -->> Агрегатные функции (позволяют производить какие-либо расчеты)
        /*$data = DB::table ('country')->count ();*/ // Если мы хотим посчитать количество записей в таблице 'country', используем метод count

        /*$data = DB::table ('country')->max ('Population');*/ // Если нам нужно найти максимальное значение в какой-либо колонке, мы используем метод max с указанием названия колонки
        /*$data = DB::table ('country')->min ('Population');*/
        /*$data = DB::table ('country')->sum ('Population');*/
        /*$data = DB::table ('country')->avg ('Population');*/ // Расчет среднего арифметического

        // Метод distinct позволяет отбрасывать повторяющиеся результаты и оставлять в единственном числе выборку в указанной колонке
        /*$data = DB::table('city')->select ('CountryCode')->distinct ()->get();*/


        // -->> Функции объединения таблиц (JOIN)
        /*$data = DB::table ('city')->select ('city.ID', 'city.Name as city_name', 'country.Code', 'country.Name as country_name')->limit(10)->join ('country', 'city.CountryCode', '=', 'country.Code')->orderBy ('city.ID')->get();*/ // Для объединения таблиц city | country мы сначала выбираем таблицу 'city', выбираем данные, которые нам нужны select ('city.ID', 'city.Name as city_name', 'country.Code', 'country.Name as country_name'), указываем лимит выборки limit(10), начинаем присоединять таблицы с помощью метода join: первым аргументом передаем название присоединяемой таблицы 'country', вторым аргументом передаем признаки, по которому мы будем объединять таблицы: признак первой таблицы 'city.CountryCode' затем оператор '=' признаку второй таблицы 'country.Code'. Если мы хотим, чтобы данные были отсортированы по конкретному столбцу, используем метод orderBy ('city.ID'). Для отображения результата, используем метод get.

//        dd ($data);

//        return view ('home');
//    }




/* ---------- Eloquent ORM (Работа с моделями БД с помощью Eloquent ORM (Object-Relational Mapping, рус. объектно-реляционное отображение, или преобразование. ORM — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных». ORM позволяет запрашивать данные из реляционной БД и манипулировать ими, используя объектно-ориентированную модель. Таким образом, можно взаимодействовать с данными через код без использования языка SQL.) -----------*/

    /*
    Таблица 1 – Достоинства и недостатки технологии ORM
    * Достоинства
    1) возможность использования только языка
    программирования, на котором уже ведется
    разработка программного продукта;
    2) легко перейти с одной базы данных на
    другую, так как в основе ORM лежит
    абстрагирование;
    3) возможность использовать механизмы ООП
    для упрощения работы с данными;
    4) в большинстве готовых ORM реализованы
    полезные функции, такие как транзакции,
    миграция, потоки;
    5) сокращение количество кода, которое
    приводит к тому, что код легче поддерживать и
    он содержит меньше ошибок.

     * Недостатки
    1) необходимо изучать функционал и
    варианты использования той или иной
    технологии ORM;
    2) для решения большинства ошибок,
    связанных с ORM, необходимо понимание ее
    внутренней архитектуры и алгоритмов работы,
    что не является легкой задачей;
    3) при хороших знаниях SQL, написание
    собственных запросов может привести к более
    эффективному использованию базы данных.
     */

    /* -->>> Мы работаем с записями БД как с объектами. Каждая запись, которую мы добавляем, изменяем, удаляем - это объект и у этого объекта есть свойства. Например, в таблице posts первая запись - будет объектом и у данного объекта будет набор свойств, которые соответствуют колонкам в данной таблице (id, title, content, created_at, updated_at)  */

    public function index () {
        // Как нам записать что-то в модель (в таблицу posts)?
        $post = new Post(); // Создаем объект нашей модели и заполняем его данными
        $post->title = 'Статья 2';
//        $post->content = 'Контент статьи 1';
        $post->save (); // Вызываем у модели метод save для сохранения данных








        return view ('home');
    }















}
