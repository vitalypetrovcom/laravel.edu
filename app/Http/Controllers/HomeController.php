<?php

namespace App\Http\Controllers;

use App\Models\City;
use App\Models\Country;
use App\Models\Post;
use App\Models\Rubric;
use App\Models\Tag;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Support\Facades\DB; // Автоматически прописываем пространство имен для использования класса Facades\DB

class HomeController extends Controller { // Контроллер (класс) для работы с главной страницей
// -->> LARAVEL по умолчанию, возвращает данные в формате JSON!

//    public function index () { // Метод для вывода на главную страницу


/* ---------- Running SQL Queries (Выполнение raw SQL запросов -----------*/


        // Метод INSERT (добавляет записи в соответствующие таблицы существующей БД). Возвращает true|false
        /*$query = DB::insert ("INSERT INTO posts (title, content, created_at, updated_at) VALUES (?, ?, ?, ?)", ['Статья 3', 'Контент статьи 3', NOW(), NOW()]);*/
//        $query = DB::insert ("INSERT INTO posts (title, content) VALUES (?,?)", ['Статья 5', 'Контент статьи 5']); // Вставляем в таблицу posts в БД в поля title, content данные 'Статья 3', 'Контент статьи 3'
//        var_dump ($query);
        /*DB::insert ("INSERT INTO posts (title, content) VALUES (:title,:content)", ['content' => 'Контент статьи 5', 'title' => 'Статья 5']); */// Вариант написания запроса с использованием именованных параметров :title,:content. При указании их значений, мы можем их перечислить в произвольной последовательности ['content' => 'Контент статьи 5', 'title' => 'Статья 5']

        // Метод UPDATE (обновляет записи в соответствующих таблицах существующей БД). Возвращает количество измененных записей
        /*DB::update ("UPDATE posts SET created_at = ?, updated_at = ? WHERE created_at IS NULL OR updated_at IS NULL", [NOW(), NOW()]);*/ // Обновим данные для таблицы posts и установим новые значения для полей created_at = ?, updated_at = ? значения которых пустые - IS NULL


        // Метод DELETE (удаляет записи в соответствующих таблицах существующей БД). Возвращает количество удаленных записей
        /*DB::delete ("DELETE FROM posts WHERE id = ?", [5]);*/ // Удалим данные (запись) из таблицы posts, id которой равен [5]



        // Метод SELECT (выбирает записи из соответствующих таблиц существующей БД). Возвращает массив записей
        /*$posts = DB::select ("SELECT * FROM posts WHERE id > :id", ['id' => 2]);*/ // Создадим переменную и присвоим ей значение выборки из БД laravel таблица posts используя класс Facades\DB и метод select. В результате получим массив с данными в формате json. При выполнении условия, мы используем именованный параметр ":id" и задаем ему значение ['id' => 2]
//        return $posts;


        /*dump (config ('app.timezone')); // config - это функция хелпер, она так же может вернуть значение или она может его установить function config($key = null, $default = null)
        dump (config ('database.connections.mysql.database')); // Если нам нужно вывести значение переменной, которая находится в файле в многомерном массиве, тогда мы указываем полный путь к переменной, начиная с названия файла, перечислением ключей массива до нужного ключа, отделяя каждый новый ключ точкой. 'database' => env('DB_DATABASE', 'forge') - означает, что если в настройках окружения переменной не указана настройка 'DB_DATABASE' (нет такой записи), тогда ключу 'database' будет присвоено значение 'forge'

        dump ($_ENV); // Распечатка настроек глобальной переменной $_ENV
        dump ($_ENV['DB_CONNECTION']); // Распечатка значения конкретной переменной 'DB_CONNECTION' из глобального массива $_ENV*/

//        return view ('home', ['res' => 5, 'name' => 'John']); // Подключаем шаблон для вывода вида

//    }

    public function test () { //

       return __METHOD__;

    }

    // -->> Listening For Query Events - Мы можем отслеживать SQL запросы и те "привязки" (['id' => 2]) которые выполняет Laravel. Если мы хотим получить каждый выполненный запрос, мы можем использовать специальный метод "listen". Данный метод мы можем использовать для логирования запросов, для отладки и при прочей необходимости. Сделать это можно в AppServiceProvider.php

    // -->> Database Transactions - В Laravel есть удобный метод для механизма транзакций (транзакции обеспечивают целостность данных в БД). Например, мы работаем одновременно с несколькими таблицами (таблицы category | posts), если мы удаляем категорию, нам нужно удалить и посты, которые к ней привязаны. Если мы вдруг, удалим категорию и что-то пойдет не так с удалением постов - у нас получится в БД удаленной категории уже нет, а сами привязанные посты остались. Нам нужно сделать так, чтобы: ИЛИ удалялись и категория и связанные посты, ИЛИ не удалялось нечего (обеспечение целостности БД). Для этого:
/*    public function index () {

        DB::beginTransaction (); // Запускаем транзакцию
        try {

            // Выполняем запросы
            DB::update ("UPDATE posts SET created_at = ? WHERE created_at IS NULL ", [NOW()]);
            DB::update ("UPDATE posts SET updated_at = ? WHERE updated_at IS NULL ", [NOW()]);

            DB::commit (); // Если оба запроса выполнятся без ошибок, тогда мы их commit
        } catch (\Exception $e) {

            DB::rollBack (); // Откатим изменения
            echo $e->getMessage (); // Выводим информацию об ошибке в браузер
        }


        $posts = DB::select ("SELECT * FROM posts WHERE id > :id", ['id' => 2]);
        return $posts;
    }*/

// -->> Выполнение запроса общего типа

//Некоторые операторы базы данных не возвращают никакого значения. Для этих типов операций вы можете использовать метод statement фасада DB:
//DB::statement('drop table users');



/* ---------- Database: Query Builder (Выполнение SQL запросов с помощью конструктора запросов -----------*/


//    public function index () {

        /*$data = DB::table ('country')->get ();*/ // Объявляем переменную $data и будем работать с конструктором запросов. Для этого, нам нужно обратиться к классу DB и использовать метод table, который укажет на нужную нам таблицу. Метод table возвращает экземпляр конструктора запросов и позволяет добавлять к данному запросу дополнительные условия. Для получения данных используем метод get

        /*$data = DB::table ('country')->limit (5)->get ();*/ // Чтобы ограничить выборку данных, используем метод limit с указанием числа отображаемых записей limit (5) (первые 5 стран). По умолчанию, при выборке 5 стран не всегда может быть гарантирована выдача в алфавитном порядке (обычно по первому полю). Чтобы гарантированно получить ожидаемый результат, нужно использовать по конкретному полю ORDER BY имя_поля ASC|DESC

        /*$data = DB::table ('country')->select ('Code', 'Name')->limit (5)->get ();*/ // Чтобы выбрать из данной выборке по каждой записи только часть полей используем метод select - select ('Code', 'Name')

        /*$data = DB::table ('country')->select ('Code', 'Name')->first ();*/ // Метод first - он позволяет вернуть первую запись из таблицы

        /*$data = DB::table ('country')->select ('Code', 'Name')->orderBy ('Code', 'desc')->first ();*/ // Устанавливаем порядок сортировки используя метод orderBy - передаем колонку для сортировки и вид сортировки ASC | DESC (по умолчанию ASC)

        /*$data = DB::table ('city')->select ('ID', 'Name')->find (2);*/ // Мы можем выбрать единственную запись по ID из таблицы city используя метод find и указываем ID записи (2) - "select `ID`, `Name` from `city` where `id` = ? limit 1"

// -->> В Laravel нет необходимости подготавливать (безопасно) SQL запрос ("DELETE FROM posts WHERE id = ?", [5]). Программа делает это за нас по умолчанию: (предыдущий запрос преобразован) "select `ID`, `Name` from `city` where `id` = ? limit 1"

        /*$data = DB::table ('city')->select ('ID', 'Name')->where ('id', '=',2)->get ();*/ // Мы можем более гибко управлять условиями для выборки данных используя метод where. Здесь мы можем передать три аргумента: первый - колонка, которая участвует в условии, второй - оператор (=,>,< итд) (указывать не всегда обязательно), третий - значение, которое участвует в условии. Для получения данных используем метод get - получаем многомерный массив

        /*$data = DB::table ('city')->select ('ID', 'Name')->where ([
            ['id', '>',  1],
            ['id', '<',  5],
        ])->get ();*/ // Если мы хотим использовать одновременно несколько условий, тогда в методе where мы указываем массив с перечисленными в нем условиями в виде отдельных массивов для каждого условия (многомерный массив)

        /*$data = DB::table ('city')->where ('id', '<',  5)->value ('Name'); */// Если нам нужно получить значение только одного столбца, но без использования метода select - для этого мы используем метод value: аргументом мы указываем название колонки, значение которой мы хотим получить (это не массив, это будет строка)

        /*$data = DB::table ('country')->limit (10)->pluck ('Name', 'Code');*/ // Чтобы нам получить все значения конкретного столба, мы используем метод pluck. Для того, чтобы ключами были идентификаторы, мы указываем в методе pluck второй аргумент с указанием колонки идентификаторов 'Code'

        // -->> Агрегатные функции (позволяют производить какие-либо расчеты)
        /*$data = DB::table ('country')->count ();*/ // Если мы хотим посчитать количество записей в таблице 'country', используем метод count

        /*$data = DB::table ('country')->max ('Population');*/ // Если нам нужно найти максимальное значение в какой-либо колонке, мы используем метод max с указанием названия колонки
        /*$data = DB::table ('country')->min ('Population');*/
        /*$data = DB::table ('country')->sum ('Population');*/
        /*$data = DB::table ('country')->avg ('Population');*/ // Расчет среднего арифметического

        // Метод distinct позволяет отбрасывать повторяющиеся результаты и оставлять в единственном числе выборку в указанной колонке
        /*$data = DB::table('city')->select ('CountryCode')->distinct ()->get();*/


        // -->> Функции объединения таблиц (JOIN)
        /*$data = DB::table ('city')->select ('city.ID', 'city.Name as city_name', 'country.Code', 'country.Name as country_name')->limit(10)->join ('country', 'city.CountryCode', '=', 'country.Code')->orderBy ('city.ID')->get();*/ // Для объединения таблиц city | country мы сначала выбираем таблицу 'city', выбираем данные, которые нам нужны select ('city.ID', 'city.Name as city_name', 'country.Code', 'country.Name as country_name'), указываем лимит выборки limit(10), начинаем присоединять таблицы с помощью метода join: первым аргументом передаем название присоединяемой таблицы 'country', вторым аргументом передаем признаки, по которому мы будем объединять таблицы: признак первой таблицы 'city.CountryCode' затем оператор '=' признаку второй таблицы 'country.Code'. Если мы хотим, чтобы данные были отсортированы по конкретному столбцу, используем метод orderBy ('city.ID'). Для отображения результата, используем метод get.

//        dd ($data);

//        return view ('home');
//    }




/* ---------- Eloquent ORM (Работа с моделями БД с помощью Eloquent ORM (Object-Relational Mapping, рус. объектно-реляционное отображение, или преобразование. ORM — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных». ORM позволяет запрашивать данные из реляционной БД и манипулировать ими, используя объектно-ориентированную модель. Таким образом, можно взаимодействовать с данными через код без использования языка SQL.) -----------*/

    /*
    Таблица 1 – Достоинства и недостатки технологии ORM
    * Достоинства
    1) возможность использования только языка
    программирования, на котором уже ведется
    разработка программного продукта;
    2) легко перейти с одной базы данных на
    другую, так как в основе ORM лежит
    абстрагирование;
    3) возможность использовать механизмы ООП
    для упрощения работы с данными;
    4) в большинстве готовых ORM реализованы
    полезные функции, такие как транзакции,
    миграция, потоки;
    5) сокращение количество кода, которое
    приводит к тому, что код легче поддерживать и
    он содержит меньше ошибок.

     * Недостатки
    1) необходимо изучать функционал и
    варианты использования той или иной
    технологии ORM;
    2) для решения большинства ошибок,
    связанных с ORM, необходимо понимание ее
    внутренней архитектуры и алгоритмов работы,
    что не является легкой задачей;
    3) при хороших знаниях SQL, написание
    собственных запросов может привести к более
    эффективному использованию базы данных.
     */

    /* -->>> Мы работаем с записями БД как с объектами. Каждая запись, которую мы добавляем, изменяем, удаляем - это объект и у этого объекта есть свойства. Например, в таблице posts первая запись - будет объектом и у данного объекта будет набор свойств, которые соответствуют колонкам в данной таблице (id, title, content, created_at, updated_at)  */



    public function index () {
        // Как нам записать что-то в модель (в таблицу posts)?
        /*$post = new Post(); */// Создаем объект нашей модели и заполняем его данными
       /* $post->title = 'Статья 2';*/
//        $post->content = 'Контент статьи 1';
        /*$post->save (); */// Вызываем у модели метод save для сохранения данных

// Сделаем выборку данных из БД. Для выборки данных мы можем использовать методы all | get. All - выбирает все что есть в таблице указанной модели, а метод Get позволяет нам работать с конструктором запросов (мы можем обратиться к модели и вызвать нужный нам метод, который позволяет сделать выборку из БД (where, limit) и затем вызвать метод get для отображения полученных данных

// Метод all
        /*$data = Country::all();*/ // Получим все записи таблицы country - Обращаемся к модели Country и вызываем метод all

// Метод limit
//        $data = Country::limit(5)->get(); // Модель не распознает метод limit (Method 'limit' not found in \App\Models\Country). Чтобы решить эту проблему, есть два способа:
        // 1:
        /*$data = Country::query()->limit(5)->get();*/ // Используем метод query (Метод вернет нам нужный нам Builder. После этого PHPStorm начинает видеть прочие методы)

        // 2: Можно обойтись без query(), но использовать возможности phpDoc (в файле модели Country.php прописываем примесь @mixin Builder (нам будут доступны в этой модели все методы))
        /*$data = Country::limit(5)->get ();*/
        /*$data = Country::where ('Code', '<', 'ALB')->select ('Code', 'Name')->offset (1)->limit (2)->get ();*/

        // Метод find - позволяет найти все записи по идентификатору
        /*$data = City::find (5);*/
        /*$data = Country::find ('AGO');*/

// Добавить данные (запись) в таблицу posts БД
        // 1:
        /*$post = new Post();
        $post->title = 'Post 4';
        $post->content = 'Content post 4';
        $post->save ();*/

        // 2: В Ларавель есть массовое назначение свойств:
        /*$post = Post::create (['title' => 'Post 8', 'content' => 'Content post 8']);*/ // На вход мы должны передать массив, где ключом будет название поля, а значением - значение для данного поля. Для того, чтобы данный метод работал корректно, нам нужно добавить ключ 'title' в "белый список полей" (массив fillable), разрешенных для массового заполнения таким способом

        // 3: Добавление с помощью метода fill
        /*$post = new Post();
        $post->fill (['title' => 'Post 8', 'content' => 'Content post 8']); // На вход метода передаем массив с данными в формате ключ-значение
        $post->save ();*/

// Обновить данные (запись) в таблице posts БД
        /*$post = Post::find (6); // Получаем запись по ID
        $post->content = 'Content post 6'; // Записываем в свойство content значение 'Content post 6'
        $post->save (); // Сохраняем запись в БД*/

// Обновить массово данные (несколько записей) в таблице posts БД
        /*Post::where ('id', '>', 3) // Используя модель Post, метод where (указываем условия выборки) и метод update (указываем значения в каких полях на что поменять
            ->update (['updated_at' => NOW()]);*/


// Удаление записей в таблице posts БД. Для удаления записей есть 2 метода: метод delete и метод destroy
        // 1. Метод delete. Для того, чтобы удалить запись методом delete мы должны сначала ее найти
        /*$post = Post::find (7);
        $post->delete ();*/ // Повторный вызов запроса выдаст ошибку (вместо ожидаемого объекта метод delete получит NULL - тк запись не существует

        // 2. Метод destroy. Без создания объекта мы указываем ID записи, которую нужно удалить
        /*Post::destroy (8);*/ // Повторный вызов запроса НЕ выдаст ошибку (мы не обращаемся к объекту - мы объект не создаем). Данный метод может принимать на вход строку со значениями id или массив со значениями id
        /*Post::destroy (4,5); // строку со значениями id
        Post::destroy ([4,5]); // массив со значениями id*/

//        dd ($post);



/* ---------- Eloquent: Relationships -----------*/


        /* ---------- Eloquent: Relationships - One To One (нам нужно связать две таблицы - связываем: одна запись - одна запись) -----------*/

        // Получаем рубрику для поста
        /*$post = Post::find (2); // Получим пост с id = 2
//        dump ($post); // Распечатаем весь объект $post
        dump ($post->title, $post->rubric->title); */// Можем распечатать одно конкретное свойство title объекта $post. Так же, мы можем добавить свойство rubric (хотя это метод, но здесь мы к нему обращаемся как к свойству $post->rubric). Через это свойство мы можем обратиться к названию рубрики $post->rubric->title.

        // Получаем пост для рубрики
        /*$rubric = Rubric::find(3); // Получаем нужную нам рубрику id = 3
        dump ($rubric->title, $rubric->post->title);*/ // Распечатаем название рубрики $rubric->title. Дополнительно, обращаемся к виртуальному свойству post используя объект $rubric и получаем название поста $rubric->post->title, связанного с этой рубрикой


        /* ---------- Eloquent: Relationships - One To Many (нам нужно связать две таблицы - связываем: одна запись - много записей) -----------*/

        // В случае с рубриками
        /*$rubric = Rubric::find(1); // Получаем нужную нам рубрику id = 1
        dump ($rubric->posts);*/ // Распечатаем виртуальное свойство posts (здесь метод posts выступает в качестве виртуального свойства) используя объект $rubric. Мы получаем массив - из двух постов, которые связаны с данной рубрикой
//        $rubric = Rubric::find(1)->posts; // Количество связанных записей получаем в одну строку. Это работает потому, что эти связи (rubric-posts) служат в качестве конструктора запросов, это значит, что мы дополнительно еще можем использовать условия после ->posts
        /*$posts = Rubric::find(1)->posts()->select ('title')->where ('id', '>', '2')->get ();*/ // Получаем все названия постов select ('title') из рубрики Rubric::find(1), которые соответствуют условиям where ('id', '>', '2') и выводим их методом get
        /*dump ($posts);*/



        // В случае с постами
        /*$post = Post::find (2); // Получим пост с id = 2
        dump ($post->title, $post->rubric->title);*/ // Распечатаем название поста $post->title и название рубрики, привязанной к нему $post->rubric->title



        /* ---------- Eloquent: Relationships - Eager Loading (Жадная загрузка) -----------*/

        // Ленивая загрузка
        /*$posts = Post::where ('id', '>', 1)->get (); // Получим все посты, соответствующие условию where ('id', '>', 1) и выведем их методом get в цикле
        foreach ($posts as $post) {
            dump ($post->title, $post->rubric->title); // Мы хотим увидеть название title каждого поста и название рубрик этих постов
        }*/

        // Жадная загрузка
        /*$posts = Post::with ('rubric')->where ('id', '>', 1)->get (); // Получим все посты используя метод with (жадная загрузка), где мы указываем связь, которую нужно жадно загрузить (те мы получаем посты и сразу же - используя связь - получаем все рубрики, которые связаны с этими постами), соответствующие условию where ('id', '>', 1) и выведем их методом get в цикле. В случае с ленивой загрузкой, мы получаем названия рубрик только тогда, когда они нам нужны (когда мы запрашиваем эту связь) dump ($post->title, $post->rubric->title) путем многих дополнительных SQL запросов (количество дополнительных запросов зависит от количества постов); В случае жадной загрузки мы получаем названия рубрик сразу же независимо от того, нужны они нам или не нужны, получаем их только один раз и только одним дополнительным SQL запросом
        foreach ($posts as $post) {
            dump ($post->title, $post->rubric->title); // Мы хотим увидеть название title каждого поста и название рубрик этих постов
        }*/


        /* ---------- Eloquent: Relationships - Many To Many (нам нужно связать уже не две таблицы, а нам нужно связать эти две таблицы посредством третьей (промежуточной) таблицы) -----------*/
        /* К одному посту можно присвоить много различных тегов, при этом, один и тот же тег может принадлежать к разным постам */

        // Получаем посты для тегов
        /*$post = Post::find (1); // Получаем пост 1
        dump ($post->title); // Выводим название поста 1
        foreach ($post->tags as $tag) { // В цикле используя виртуальное свойство tags объекта $post мы выводим названия связанных с постом 1 тегов - dump ($tag->title)
            dump ($tag->title);
        }*/

        // Получаем теги для постов
        /*$tag = Tag::find (2); // Получаем тег 2
        dump ($tag->title); // Выводим название тега 2
        foreach ($tag->posts as $post) { // В цикле используя виртуальное свойство posts объекта $tags мы выводим названия связанных с тегом 2 постов - dump ($post->title)
            dump ($post->title);
        }*/









        return view ('home');
    }















}
