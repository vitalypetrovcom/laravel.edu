<?php

namespace App\Http\Controllers;

use Illuminate\Support\Facades\DB; // Автоматически прописываем пространство имен для использования класса Facades\DB

class HomeController extends Controller { // Контроллер (класс) для работы с главной страницей
// -->> LARAVEL по умолчанию, возвращает данные в формате JSON!

//    public function index () { // Метод для вывода на главную страницу

        // Метод INSERT (добавляет записи в соответствующие таблицы существующей БД). Возвращает true|false
        /*$query = DB::insert ("INSERT INTO posts (title, content, created_at, updated_at) VALUES (?, ?, ?, ?)", ['Статья 3', 'Контент статьи 3', NOW(), NOW()]);*/
//        $query = DB::insert ("INSERT INTO posts (title, content) VALUES (?,?)", ['Статья 5', 'Контент статьи 5']); // Вставляем в таблицу posts в БД в поля title, content данные 'Статья 3', 'Контент статьи 3'
//        var_dump ($query);
        /*DB::insert ("INSERT INTO posts (title, content) VALUES (:title,:content)", ['content' => 'Контент статьи 5', 'title' => 'Статья 5']); */// Вариант написания запроса с использованием именованных параметров :title,:content. При указании их значений, мы можем их перечислить в произвольной последовательности ['content' => 'Контент статьи 5', 'title' => 'Статья 5']

        // Метод UPDATE (обновляет записи в соответствующих таблицах существующей БД). Возвращает количество измененных записей
        /*DB::update ("UPDATE posts SET created_at = ?, updated_at = ? WHERE created_at IS NULL OR updated_at IS NULL", [NOW(), NOW()]);*/ // Обновим данные для таблицы posts и установим новые значения для полей created_at = ?, updated_at = ? значения которых пустые - IS NULL


        // Метод DELETE (удаляет записи в соответствующих таблицах существующей БД). Возвращает количество удаленных записей
        /*DB::delete ("DELETE FROM posts WHERE id = ?", [5]);*/ // Удалим данные (запись) из таблицы posts, id которой равен [5]



        // Метод SELECT (выбирает записи из соответствующих таблиц существующей БД). Возвращает массив записей
        /*$posts = DB::select ("SELECT * FROM posts WHERE id > :id", ['id' => 2]);*/ // Создадим переменную и присвоим ей значение выборки из БД laravel таблица posts используя класс Facades\DB и метод select. В результате получим массив с данными в формате json. При выполнении условия, мы используем именованный параметр ":id" и задаем ему значение ['id' => 2]
//        return $posts;


        /*dump (config ('app.timezone')); // config - это функция хелпер, она так же может вернуть значение или она может его установить function config($key = null, $default = null)
        dump (config ('database.connections.mysql.database')); // Если нам нужно вывести значение переменной, которая находится в файле в многомерном массиве, тогда мы указываем полный путь к переменной, начиная с названия файла, перечислением ключей массива до нужного ключа, отделяя каждый новый ключ точкой. 'database' => env('DB_DATABASE', 'forge') - означает, что если в настройках окружения переменной не указана настройка 'DB_DATABASE' (нет такой записи), тогда ключу 'database' будет присвоено значение 'forge'

        dump ($_ENV); // Распечатка настроек глобальной переменной $_ENV
        dump ($_ENV['DB_CONNECTION']); // Распечатка значения конкретной переменной 'DB_CONNECTION' из глобального массива $_ENV*/

//        return view ('home', ['res' => 5, 'name' => 'John']); // Подключаем шаблон для вывода вида

//    }

    public function test () { //

       return __METHOD__;

    }

    // -->> Listening For Query Events - Мы можем отслеживать SQL запросы и те "привязки" (['id' => 2]) которые выполняет Laravel. Если мы хотим получить каждый выполненный запрос, мы можем использовать специальный метод "listen". Данный метод мы можем использовать для логирования запросов, для отладки и при прочей необходимости. Сделать это можно в AppServiceProvider.php

    // -->> Database Transactions - В Laravel есть удобный метод для механизма транзакций (транзакции обеспечивают целостность данных в БД). Например, мы работаем одновременно с несколькими таблицами (таблицы category | posts), если мы удаляем категорию, нам нужно удалить и посты, которые к ней привязаны. Если мы вдруг, удалим категорию и что-то пойдет не так с удалением постов - у нас получится в БД удаленной категории уже нет, а сами привязанные посты остались. Нам нужно сделать так, чтобы: ИЛИ удалялись и категория и связанные посты, ИЛИ не удалялось нечего (обеспечение целостности БД). Для этого:
    public function index () {

        DB::beginTransaction (); // Запускаем транзакцию
        try {

            // Выполняем запросы
            DB::update ("UPDATE posts SET created_at = ? WHERE created_at IS NULL ", [NOW()]);
            DB::update ("UPDATE posts SET updated_at = ? WHERE updated_at IS NULL ", [NOW()]);

            DB::commit (); // Если оба запроса выполнятся без ошибок, тогда мы их commit
        } catch (\Exception $e) {

            DB::rollBack (); // Откатим изменения
            echo $e->getMessage (); // Выводим информацию об ошибке в браузер
        }


        $posts = DB::select ("SELECT * FROM posts WHERE id > :id", ['id' => 2]);
        return $posts;



    }

// -->> Выполнение запроса общего типа
//Некоторые операторы базы данных не возвращают никакого значения. Для этих типов операций вы можете использовать метод statement фасада DB:
//DB::statement('drop table users');






}
