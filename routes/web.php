<?php

use Illuminate\Support\Facades\Route;

/*
|--------------------------------------------------------------------------
| Web Routes
|--------------------------------------------------------------------------
|
| Here is where you can register web routes for your application. These
| routes are loaded by the RouteServiceProvider within a group which
| contains the "web" middleware group. Now create something great!
|
*/

/*
 * Доступные HTTP-методы маршрутизатора
Route::get($uri, $callback); - Получить данные - данный метод принимает значение строки запроса пользователя (метод, которым передаются данные когда мы обращаемся к странице по ссылке или набираем адрес вручную)
Route::post($uri, $callback); - Передать данные - метод используется, когда мы передаем данные а страницу методом POST через формы для заполнения и отправки
Route::put($uri, $callback); - Обновить данные - метод используется для обновления данных ресурса
Route::patch($uri, $callback);
Route::delete($uri, $callback); - Удалить данные - метод используется для удаления данных ресурса
Route::options($uri, $callback);
*/



/*Route::get('/', function () {
    return view('welcome');
});*/

/*Route::get('/', function () {
    return view('home');
});*/

/*Route::get ( '/', function () {
    return '<h1> Hello, world! </h1>';
} );*/

/*Route::get ( '/', function () {
    $res = 2 + 3;
    $name = 'John';
    return view ('home')->with ('var', $res); // 1-й вариант передачи данных в шаблон: Используем метод with, чтобы передать наши данные: передаем переменную 'var' со значением переменной $res
} );*/

/*Route::get ( '/', function () {
    $res = 2 + 3;
    $name = 'John';
    return view ('home', ['res' => $res, 'name' => $name]); // 2-й вариант передачи данных в шаблон: Используем ассоциативный массив для передачи данных в формате ключ => значение
})->name ('home');*/

/*Route::get ( '/', function () {
    $res = 2 + 3;
    $name = 'John';
    return view ('home', compact ('res', 'name')); // 3-й вариант передачи данных в шаблон: Используем нативную функцию PHP compact для передачи данных (мы передаем в эту функцию в виде строк названия переменных)
} );*/

/*Route::get ( '/about', function () { // Маршрутизация для страницы "about" сайта
    return view ('about');
} );*/

/*Route::get ( '/contact', function () { // Маршрутизация для страницы "contact" сайта
    return view ('contact');
} );*/

/*Route::post ('/send-email', function () {
    if (!empty($_POST)) {
        dump ($_POST); // Для красивой распечатки данных в ларавель есть функция dump. Если нам нужно завершить выполнения кода после распечатки данных - мы используем функцию dd
    }
    return 'Send Email';
});*/

// 2. Если нам нужно, чтобы отправляемые данные из формы отправлялись на эту же страницу контактов, при этом передавались методом POST. В этом случае используются сразу два метода: у класса Route метод "match", где первым аргументом в виде массива мы указываем поддерживаемые методы, по которым будет доступна данная страница - методы 'post', 'get'. Вторым аргументом указываем uri страницы. Третий аргумент - коллбэкфункция с выводом представления
/*Route::match (['post', 'get'], '/contact', function () {
    if (!empty($_POST)) {
        dump ($_POST);
    }
    return view ('contact');
});*/

// Если нам нужен маршрут, который будет поддерживать все типы запросов (GET, POST, PUT, DELETE) - можно использовать метод "any" - данный маршрут будет доступен по любому запросу (GET, POST, PUT, DELETE)
/*Route::any ();*/

// 3. Использование именованных маршрутов - мы даем имя нашему маршруту - с помощью метода "name". В скобках указываем как мы хотим, чтобы наш маршрут назывался и это имя будет затем использовано во всех ссылках на данную страницу (ссылка будет корректно построена несмотря на то, что мы в запросе поменяем uri на '/contact2')
/*Route::match (['post', 'get', 'put'], '/contact', function () {
    if (!empty($_POST)) {
        dump ($_POST);
    }
    return view ('contact');
})->name ('contact');*/

// Если речь идет о статичных страницах /about, /contact итд., которые не предполагают получения и обработки данных из БД и мы захотим подключить такую страницу (вид) и ограничиться этим. В этом случае мы можем использовать для класса Route метод "view". На вход передаем uri адрес и название вида, который нужно подключить для данной страницы. Так же, при необходимости, мы можем на страницу передать какие-то данные в виде массива в виде ключа => значение
/*Route::view ('/test', 'test', ['test' => 'Test data']);*/

// Делаем редирект используя маршрутизацию. Для этого у класса "route" есть метод "redirect". Он принимает на вход параметры: uri (с которого нужно сделать редирект) и uri (куда нужно сделать редирект). По умолчанию передает статус страницы 302 (страница временно перемещена)
//Route::redirect ('/about', '/contact', 302);
//Route::redirect ('/about', '/contact', 301); // Страница перемещена постоянно
/*Route::permanentRedirect ('/about', '/contact');*/ // Аналог предыдущей записи. По умолчанию выдается статус 301


// Если нам нужно создать динамическую маршрутизацию на сайте (например, для статей), при использовании метода "get" в uri мы передаем адрес с динамическим параметром в виде переменной {id} - '/post/{id}' и затем мы эту переменную передаем в коллбекфункцию. Переменная {id} имеет ограничения по именованию: разрешены только символы [0-9a-z_]
/*Route::get ('/post/{id}', function ($id) {
    return "Post $id";
});*/

// Создадим маршрут, где в адресе дополнительно будет слаг
/*Route::get ('/post/{id}/{slug}', function ($id, $slug) {
    return "Post $id | $slug";
});*/

// Создадим маршрут, где в адресе дополнительно будет слаг И именование id и slug будет определяться шаблонами регулярных выражений
/*Route::get ('/post/{id}/{slug}', function ($id, $slug) {
    return "Post $id | $slug";
})->where (['id' =>'[0-9]+', 'slug' => '[A-Za-z0-9-]+']);*/
// Чтобы не писать маршруты таким образом, мы можем написать общую настройку и использовать ее глобально. Это мы можем сделать при помощи специального сервис-провайдера из папки app/providers - RouteServiceProvider.php
/*Route::get ('/post/{id}/{slug}', function ($id, $slug) {
    return "Post $id | $slug";
});*/


// -->> Группировка правил
// Маршрутизация для списка статей
// Используем метод prefix для добавления префикса для каждого адреса И группируем все эти адреса с помощью метода group и выполняем коллбекфункцию, в которую помещаем все наши адреса
//Route::prefix ('admin')->group ( function () {
//    Route::get ('/posts', function () {
//        return 'Posts List';
//    });
//
//    Route::get ('/post/create', function () {
//        return 'Post  Create';
//    });
//
//    Route::get ('/post/{id}/edit', function ($id) {
//        return "Edit Post $id";
//    })->name ('post');
//});

/*Route::get ('/posts', function () {
    return 'Posts List';
});

Route::get ('/post/create', function () {
    return 'Post  Create';
});

Route::get ('/post/{id}/edit', function ($id) {
    return "Edit Post $id";
});*/


// -->> Подмена метода передачи данных.
// Когда мы работаем с формами на страницах - формы могут передавать данные методами get | post. Но ларавель может принимать данные другими методами - put | delete. Для того чтобы указать в форме другой метод, мы должны использовать специальное скрытое поле с именем подчеркивание метод ИЛИ используя метод {{ method_field ('PUT') }} ИЛИ @method('PUT')


// -->> Как сделать аргументы маршрутов не обязательными
//Route::get ('/post/{id}/{slug?}', function ($id, $slug = null) {
//    return "Post $id | $slug";
//})->name ('post'); // Например, сделаем slug не обязательным аргументом, мы после slug должны поставить ? знак - slug?. Мы должны поставить значение по умолчанию $slug = null


// -->> Во всех фреймворках, при маршрутизации, более конкретные правила должны стоять выше более общих правил. Когда фреймворк идет по правилам маршрутизации и сравнивает последовательно с каждым правилом маршрут (uri), полученный от пользователя - он останавливается на том маршруте, где было найдено первое совпадение (другие маршруты рассматриваться не будут). Например, '/post/{id}/edit' более конкретная строка чем '/post/{id}/{slug?}'

// -->> Мы можем давать имена нашим маршрутам. Имена маршрутов должны быть УНИКАЛЬНЫМИ! На основании имени маршрута, мы можем сделать ссылку на маршрут. Если мы даем одинаковые имена разным маршрутам, тогда, чтобы не было проблем с маршрутизацией, мы должны добавить имя для всей группы маршрутов -->> .
/*Route::get ('/post/{id}/{slug?}', function ($id, $slug = null) {
    return "Post $id | $slug";
})->name ('post');*/

/*Route::prefix ('admin')->name ('admin.')->group ( function () { // -->> Тогда наши маршруты будут доступны по маршруту admin.post
    Route::get ('/posts', function () {
        return 'Posts List';
    });

    Route::get ('/post/create', function () {
        return 'Post  Create';
    });

    Route::get ('/post/{id}/edit', function ($id) {
        return "Edit Post $id";
    })->name ('post');
});*/

// -->> Fallback Routes. Иногда нам нужно временно перенаправлять все наши запросы на какой-то конкретный маршрут (страница 404). Если у нас нет маршрута под какие-то uri адреса, то ларавель отдает 404 ошибку и шаблон страницы с этой ошибкой. Нам может потребоваться, чтобы все несуществующие адреса перенаправлялись на какой-то конкретный маршрут (например, страница "сайт на обслуживании") - для этого существует метод "Fallback". С помощью Fallback мы можем перенаправить все запросы (для которых нет правил маршрутизации) на нужный нам адрес.
//Route::fallback ( function () { // Здесь мы указываем на какой маршрут должны идти все запросы - на главную страницу 'home'
//    return redirect()->route ('home');
//});


// Вместо редиректа, мы можем сделать свою старницу "404" и возвращать 404 ошибку. Для этого, есть вспомогательная функция "abort" - данная функция предполагает аргументы: $code (код ошибки), $message (сообщение) и массив заголовков $headers(при необходимости)

Route::fallback ( function () { // Здесь мы указываем на какой маршрут должны идти все запросы если у нас нет запрашиваемого пользователем маршрута
    abort (404, 'Oops! Page not found!');
});

// Маршрутизация для главной страницы используя контроллер и экшн 'HomeController@index'
/*Route::get ('/', 'App\Http\Controllers\HomeController@index');*/
/*Route::get ('/test', 'App\Http\Controllers\HomeController@test');*/
//Route::get ('/page/about', 'App\Http\Controllers\PageController@show'); // Маршрут для одной страницы /about
/*Route::get ('/page/{slug}', 'App\Http\Controllers\PageController@show'); */// Если мы хотим чтобы после page/ у нас названия страниц подставлялись динамически, тогда мы можем использовать переменную {slug} и независимо от того, что к нам придет в качестве slug, мы всегда будем обращаться к методу show PageController, где уже будем пытаться достать из БД контент соответствующей страницы и подключить соответствующий вид. Вид мы можем подключать каждый в отдельности (view ("pages.$slug");)
/*Route::get ('/test2', 'App\Http\Controllers\Test\TestController@index');*/

/*Route::resource ('/posts', 'App\Http\Controllers\PostController');*/ // Маршрутизация для списка постов с использованием метода resource для контроллера ресурсов PostController
/*Route::resource ('/posts', 'App\Http\Controllers\PostController', ['parameters' => [
    'posts' => 'slug',
]]);*/ // Маршрутизация для списка постов с использованием метода resource для контроллера ресурсов PostController. Для того чтобы нам для проверки правильности указания id | slug в строке запроса пользователя после /posts/, мы в метод resource передаем массив с параметрами (ключом будет 'parameters'), значением будет массив, где мы указываем имя ресурса 'posts' и как он на самом деле должен называться 'id' (мы хотим, чтобы он так назывался). Теперь, 'posts' будет называться именно 'id' и будет доступен по тем правилам, которые у нас описаны в RouteServiceProvider.php для данного аргумента (pattern ('id', '[0-9]+')). Если нам нужно будет, чтобы к имени ресурса 'posts' применялись правила для slug - мы в параметрах назовем его 'posts' => 'slug'. В таком случае при выводе в вид в файле index.blade.php и edit.blade.php при указании маршрутов мы тоже должны поменять 'post' на 'slug'
/*Route::resource ('/admin/posts', 'App\Http\Controllers\PostController', ['parameters' => [
    'posts' => 'slug',
]]);*/ // Если нужно сделать это для админки - мы добавляем в имя ресурса /admin/posts'. Весь остальной код остается прежним (его менять не нужно)


// Маршрутизация для главной страницы используя контроллер и экшн 'HomeController@index'
Route::get ('/', 'App\Http\Controllers\HomeController@index')->name ('home'); // Маршрут для показа списка постов. Дадим имена нашим шаблонам, чтобы в дальнейшем мы могли прописать корректно ссылки используя функцию Root в шаблоне

Route::get ('/create', 'App\Http\Controllers\HomeController@create')->name ('posts.create'); // Маршрут для заполнения формы данных для последующей отправки методом POST
Route::post ('/', 'App\Http\Controllers\HomeController@store')->name ('posts.store'); // Маршрут, метод post, будет указывать на тот же uri '/' (главная страница), но здесь у нас уже будет отрабатывать экшн store (данный метод принимает данные методом POST - он сохраняет данные полученные из формы



Route::get ('/page/about', 'App\Http\Controllers\PageController@show')->name ('page.about');

// Маршрут, при переходе по которому у нас будет отправляться письмо
//Route::get ('/send', 'App\Http\Controllers\ContactController@send');

// У нас на одной странице будет и форма и отправка - нам потребуется 2 метода для одного маршрута - GET | POST. Для этого используем метод match
Route::match (['get', 'post'], '/send', 'App\Http\Controllers\ContactController@send');

// Маршруты под регистрацию пользователя (1 будет выводить форму (метод GET), 2 будет отправлять заполненную форму на controller action (метод POST) и сохранять зарегистрированного пользователя. У нас UserController будет отвечать и за регистрацию и за аутентификацию.
Route::get ('/register', 'App\Http\Controllers\UserController@create')->name ('register.create'); // Маршрут для выведения формы регистрации
Route::post ('/register', 'App\Http\Controllers\UserController@store')->name ('register.store');
















